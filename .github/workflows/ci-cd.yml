name: üöÄ CI/CD Pipeline - Ordem do Dia

on:
  push:
    branches: [main, develop]
    paths-ignore:
      - "**.md"
      - "docs/**"
      - ".github/**"
      - "!.github/workflows/**"
  pull_request:
    branches: [main]
  release:
    types: [published]

env:
  PYTHON_VERSION: "3.11"

jobs:
  # üß™ TESTES E QUALIDADE
  tests:
    name: üß™ Testes e Qualidade de C√≥digo
    runs-on: windows-latest

    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4

      - name: üêç Configurar Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"

      - name: üì¶ Instalar depend√™ncias
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov black flake8 mypy bandit safety

      - name: üé® Verificar formata√ß√£o (Black)
        run: |
          black --check --diff .

      - name: üîç Linting (Flake8)
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=88 --statistics

      - name: üîí Verifica√ß√£o de seguran√ßa (Bandit)
        run: |
          Write-Host "üîç Iniciando an√°lise de seguran√ßa..."

          # An√°lise completa com JSON para processamento
          Write-Host "ÔøΩ Executando an√°lise completa..."
          bandit -r . `
            --exclude=.venv,tests,build_temp,htmlcov,distribuicao,distribuicao_completa `
            --skip=B101,B601,B603,B607 `
            -f json -o bandit-report.json
            
          # An√°lise focada em problemas cr√≠ticos
          Write-Host "üéØ Verificando problemas cr√≠ticos..."
          bandit -r . `
            --exclude=.venv,tests,build_temp,htmlcov,distribuicao,distribuicao_completa `
            --skip=B101,B601,B603,B607 `
            --severity-level medium `
            --confidence-level medium `
            --format custom `
            --msg-template "{severity}: {test_id} - {msg}"
            
          # An√°lise dos resultados
          Write-Host "üìà Analisando resultados..."
          if (Test-Path bandit-report.json) {
            $report = Get-Content bandit-report.json | ConvertFrom-Json
            $highSeverity = ($report.results | Where-Object { $_.issue_severity -eq "HIGH" }).Count
            $mediumSeverity = ($report.results | Where-Object { $_.issue_severity -eq "MEDIUM" }).Count
            
            Write-Host "- Problemas cr√≠ticos (HIGH): $highSeverity"
            Write-Host "- Problemas m√©dios (MEDIUM): $mediumSeverity"
            
            if ($highSeverity -gt 0) {
              Write-Error "‚ùå Problemas cr√≠ticos de seguran√ßa encontrados"
              exit 1
            }
          }

      - name: üõ°Ô∏è Verificar vulnerabilidades (Safety)
        run: |
          Write-Host "üîç Verificando vulnerabilidades em depend√™ncias..."

          # Verifica√ß√£o detalhada com relat√≥rio JSON
          safety check --json --output safety-report.json

          # An√°lise de resultados
          if (Test-Path safety-report.json) {
            $report = Get-Content safety-report.json | ConvertFrom-Json
            $vulnerabilities = $report.vulnerabilities.Count
            
            if ($vulnerabilities -gt 0) {
              Write-Host "‚ö†Ô∏è $vulnerabilities vulnerabilidades encontradas:"
              foreach ($vuln in $report.vulnerabilities) {
                Write-Host "- $($vuln.package): $($vuln.vulnerability_id)"
                Write-Host "  $($vuln.advisory)"
              }
              Write-Error "‚ùå Vulnerabilidades cr√≠ticas encontradas"
              exit 1
            } else {
              Write-Host "‚úÖ Nenhuma vulnerabilidade encontrada"
            }
          }

          # Verifica√ß√£o secund√°ria com sa√≠da formatada
          safety check --full-report --output text

      - name: üß™ Executar testes unit√°rios
        run: |
          Write-Host "üî¨ Iniciando suite de testes..."

          # Executar testes com paralelismo e relat√≥rios detalhados
          pytest tests/ -v -n auto --dist loadfile `
            --cov=. --cov-report=html --cov-report=xml `
            --cov-fail-under=80 `
            --junit-xml=test-results.xml `
            --durations=10 `
            --maxfail=5

          # Analisar resultados dos testes
          if (Test-Path test-results.xml) {
            Write-Host "üìä Analisando resultados dos testes..."
            [xml]$testResults = Get-Content test-results.xml
            $total = $testResults.testsuites.tests
            $failures = $testResults.testsuites.failures
            $errors = $testResults.testsuites.errors
            $skipped = $testResults.testsuites.skipped
            
            Write-Host "üìà Resumo dos Testes:"
            Write-Host "- Total: $total"
            Write-Host "- Falhas: $failures"
            Write-Host "- Erros: $errors"
            Write-Host "- Ignorados: $skipped"
            
            if ($failures -gt 0 -or $errors -gt 0) {
              Write-Error "‚ùå Falhas encontradas nos testes"
              exit 1
            }
          } else {
            Write-Error "‚ùå Arquivo de resultados n√£o encontrado"
            exit 1
          }

      - name: üìä Upload coverage para Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: true

      - name: üìà Gerar relat√≥rio de cobertura
        if: always()
        run: |
          Write-Host "üìä Gerando relat√≥rio detalhado de cobertura..."

          # Analisar XML de cobertura
          [xml]$coverage = Get-Content coverage.xml
          $totalLines = $coverage.coverage.'lines-valid'
          $coveredLines = $coverage.coverage.'lines-covered'
          $percentage = [math]::Round(($coveredLines / $totalLines) * 100, 2)

          Write-Host "üìà Cobertura de C√≥digo:"
          Write-Host "- Linhas Totais: $totalLines"
          Write-Host "- Linhas Cobertas: $coveredLines"
          Write-Host "- Porcentagem: $percentage%"

          # Verificar se atinge o m√≠nimo
          if ($percentage -lt 80) {
            Write-Error "‚ùå Cobertura abaixo do m√≠nimo de 80%"
            exit 1
          }

      - name: üìã Artefatos de relat√≥rios
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-reports
          path: |
            htmlcov/
            bandit-report.json
            safety-report.json
            coverage.xml

  # üî® BUILD DO EXECUT√ÅVEL
  build:
    name: üî® Build Execut√°vel Windows
    runs-on: windows-latest
    needs: tests
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'release'

    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4

      - name: üêç Configurar Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"

      - name: üì¶ Instalar depend√™ncias de build
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: üî® Gerar execut√°vel
        run: |
          python build_exe.py

      - name: üõ°Ô∏è An√°lise de seguran√ßa do execut√°vel
        run: |
          # Verificar se o execut√°vel foi criado
          if (Test-Path "distribuicao_completa/GeradorOD.exe") {
            Write-Host "‚úÖ Execut√°vel encontrado"
            
            # Verificar integridade do arquivo
            $hash = Get-FileHash "distribuicao_completa/GeradorOD.exe" -Algorithm SHA256
            Write-Host "üîê Hash SHA256: $($hash.Hash)"
            
            # Criar arquivo de hash para verifica√ß√£o
            $hash.Hash | Out-File "distribuicao_completa/GeradorOD.exe.sha256"
            
            # Verificar tamanho (execut√°veis muito pequenos ou grandes podem ser suspeitos)
            $size = (Get-Item "distribuicao_completa/GeradorOD.exe").Length / 1MB
            Write-Host "üìä Tamanho: $([math]::Round($size, 2)) MB"
            
            if ($size -lt 10 -or $size -gt 200) {
              Write-Host "‚ö†Ô∏è Tamanho incomum detectado - revisar se necess√°rio"
            }
            
            # Verificar se n√£o √© um arquivo de texto (indicaria falha no build)
            $fileType = file "distribuicao_completa/GeradorOD.exe" 2>$null
            if ($fileType -match "text") {
              Write-Error "‚ùå Execut√°vel parece ser arquivo de texto - build falhou"
              exit 1
            }
            
          } else {
            Write-Error "‚ùå Execut√°vel n√£o foi criado!"
            exit 1
          }

      - name: ‚úÖ Verificar execut√°vel
        run: |
          if (Test-Path "distribuicao_completa/GeradorOD.exe") {
            Write-Host "‚úÖ Execut√°vel criado com sucesso!"
            $size = (Get-Item "distribuicao_completa/GeradorOD.exe").Length / 1MB
            Write-Host "üìä Tamanho: $([math]::Round($size, 2)) MB"
          } else {
            Write-Error "‚ùå Execut√°vel n√£o foi criado!"
            exit 1
          }

      - name: üß™ Teste b√°sico do execut√°vel
        run: |
          # Teste se o execut√°vel inicia sem erros (modo CLI) com timeout
          $exePath = "distribuicao_completa/GeradorOD.exe"
          if (Test-Path $exePath) {
            Write-Host "üîç Testando execut√°vel com --help..."
            
            $startInfo = New-Object System.Diagnostics.ProcessStartInfo
            $startInfo.FileName = $exePath
            $startInfo.Arguments = "--help"
            $startInfo.UseShellExecute = $false
            $startInfo.RedirectStandardOutput = $true
            $startInfo.RedirectStandardError = $true
            
            $process = New-Object System.Diagnostics.Process
            $process.StartInfo = $startInfo
            
            try {
              $process.Start() | Out-Null
              
              # Capturar sa√≠da padr√£o e erro assincronamente
              $outputTask = $process.StandardOutput.ReadToEndAsync()
              $errorTask = $process.StandardError.ReadToEndAsync()
              
              # Esperar 5 segundos pelo --help
              if ($process.WaitForExit(5000)) {
                $output = $outputTask.Result
                $error = $errorTask.Result
                
                if ($process.ExitCode -eq 0) {
                  Write-Host "‚úÖ Execut√°vel respondeu ao --help com sucesso"
                  Write-Host "üìù Sa√≠da do --help:"
                  Write-Host $output
                  
                  # Verificar se a sa√≠da cont√©m algo √∫til
                  if ($output -match "uso:|usage:|help|ajuda") {
                    Write-Host "‚úÖ Menu de ajuda detectado!"
                  } else {
                    Write-Host "‚ö†Ô∏è Sa√≠da do --help n√£o reconhecida, mas execut√°vel respondeu"
                  }
                } else {
                  Write-Host "‚ö†Ô∏è Execut√°vel retornou c√≥digo: $($process.ExitCode)"
                  Write-Host "üìù Sa√≠da de erro:"
                  Write-Host $error
                  exit 1
                }
              } else {
                Write-Host "‚ùå Timeout: --help n√£o respondeu em 5 segundos"
                $process.Kill()
                exit 1
              }
            }
            catch {
              Write-Error "‚ùå Erro ao executar teste: $_"
              exit 1
            }
            finally {
              if (-not $process.HasExited) {
                $process.Kill()
              }
            }
          } else {
            Write-Error "‚ùå Execut√°vel n√£o encontrado para teste!"
            exit 1
          }

      - name: üì¶ Criar pacote de distribui√ß√£o
        run: |
          # Executar script de assinatura (sem certificado, apenas valida√ß√£o)
          Write-Host "üîê Executando valida√ß√£o de seguran√ßa do execut√°vel..."
          pwsh -ExecutionPolicy Bypass -File "sign_executable.ps1" -ExecutablePath "distribuicao_completa/GeradorOD.exe"

          # Criar ZIP com distribui√ß√£o completa
          $version = "v2.0-$(Get-Date -Format 'yyyyMMdd')-$($env:GITHUB_SHA.Substring(0,7))"
          Compress-Archive -Path "distribuicao_completa/*" -DestinationPath "OrdemDoDia-$version.zip"

          # Criar hash do arquivo
          $hash = Get-FileHash "OrdemDoDia-$version.zip" -Algorithm SHA256
          $hash.Hash | Out-File "OrdemDoDia-$version.zip.sha256"

          Write-Host "üì¶ Pacote criado: OrdemDoDia-$version.zip"

          # Criar manifesto de seguran√ßa
          $manifest = @{
            version = $version
            build_date = (Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC")
            commit_hash = $env:GITHUB_SHA
            executable_hash = (Get-FileHash "distribuicao_completa/GeradorOD.exe" -Algorithm SHA256).Hash
            package_hash = $hash.Hash
            security_scan = "passed"
            signed = "false"
          }

          $manifest | ConvertTo-Json | Out-File "OrdemDoDia-$version.manifest.json" -Encoding UTF8
          Write-Host "üõ°Ô∏è Manifesto de seguran√ßa criado"

      - name: üì§ Upload artefatos
        uses: actions/upload-artifact@v4
        with:
          name: executavel-windows
          path: |
            OrdemDoDia-*.zip
            OrdemDoDia-*.zip.sha256
            OrdemDoDia-*.manifest.json
          retention-days: 30

  # üöÄ RELEASE AUTOM√ÅTICO
  release:
    name: üöÄ Create Release
    runs-on: windows-latest
    needs: [tests, build]
    if: github.event_name == 'release' && github.event.action == 'published'

    steps:
      - name: üì• Download artefatos
        uses: actions/download-artifact@v4
        with:
          name: executavel-windows

      - name: üöÄ Upload para Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            OrdemDoDia-*.zip
            OrdemDoDia-*.zip.sha256
            OrdemDoDia-*.manifest.json
          body: |
            ## üéâ Nova vers√£o do Ordem do Dia!

            ### üì¶ Arquivos de Download
            - **OrdemDoDia-*.zip**: Aplica√ß√£o completa com execut√°vel
            - **OrdemDoDia-*.zip.sha256**: Hash SHA256 para verifica√ß√£o
            - **OrdemDoDia-*.manifest.json**: Manifesto de seguran√ßa e integridade

            ### üöÄ Como Usar
            1. Baixe o arquivo ZIP
            2. Extraia em uma pasta de sua escolha
            3. Execute `GeradorOD.exe`
            4. Siga as instru√ß√µes na interface

            ### üìã Requisitos
            - Windows 10/11 (64-bit)
            - 4GB RAM m√≠nimo
            - 100MB espa√ßo livre

            ### üÜò Suporte
            - üìñ Manual: Inclu√≠do no ZIP
            - üêõ Issues: [GitHub Issues](https://github.com/${{ github.repository }}/issues)
            - üìß Email: [Contato do desenvolvedor]

            ---
            **Testado em**: Windows 10, Windows 11  
            **Build**: ${{ github.sha }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # üìã NOTIFICA√á√ïES E LINKS
  notify:
    name: üìã Notifica√ß√µes
    runs-on: ubuntu-latest
    needs: [tests, build]
    if: always()

    steps:
      - name: üîó Coment√°rio com link do artefato
        if: needs.tests.result == 'success' && needs.build.result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const runId = context.runId;
            const repo = context.repo;
            const sha = context.sha;

            const artifactUrl = `https://github.com/${repo.owner}/${repo.repo}/actions/runs/${runId}`;
            const downloadUrl = `${artifactUrl}#artifacts`;

            const comment = `## üéâ Build Conclu√≠do com Sucesso!

            ### üì¶ **Download Direto do Execut√°vel**
            üîó **[BAIXAR EXECUT√ÅVEL AQUI](${downloadUrl})**

            ### üìä **Resultados do Build**
            - ‚úÖ **Testes**: ${context.payload.workflow_run?.conclusion || 'Passou'} 
            - ‚úÖ **Build**: Sucesso
            - üèóÔ∏è **Commit**: \`${sha.substring(0, 7)}\`
            - üìÖ **Data**: ${new Date().toLocaleString('pt-BR')}

            ### üöÄ **Links R√°pidos**
            - üìã [Ver Logs Completos](${artifactUrl})
            - üì¶ [Download Artefatos](${downloadUrl})
            - üîç [Detalhes do Commit](https://github.com/${repo.owner}/${repo.repo}/commit/${sha})

            ### üí° **Como Baixar**
            1. Clique no link **"BAIXAR EXECUT√ÅVEL AQUI"** acima
            2. Role at√© a se√ß√£o "Artifacts" 
            3. Clique em **"executavel-windows"**
            4. O download come√ßar√° automaticamente

            ---
            ü§ñ *Coment√°rio autom√°tico do CI/CD*`;

            // Se for um push, comenta no commit
            if (context.eventName === 'push') {
              await github.rest.repos.createCommitComment({
                owner: repo.owner,
                repo: repo.repo,
                commit_sha: sha,
                body: comment
              });
            }

            // Se for um PR, comenta no PR
            if (context.payload.pull_request) {
              await github.rest.issues.createComment({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: context.payload.pull_request.number,
                body: comment
              });
            }

      - name: üí¨ Notificar sucesso
        if: needs.tests.result == 'success' && needs.build.result == 'success'
        run: |
          echo "‚úÖ Pipeline executado com sucesso!"
          echo "üß™ Testes: PASSOU"
          echo "üî® Build: PASSOU"
          echo "üîó Link do artefato postado automaticamente!"

      - name: üö® Notificar falha
        if: needs.tests.result == 'failure' || needs.build.result == 'failure'
        run: |
          echo "‚ùå Pipeline falhou!"
          echo "üß™ Testes: ${{ needs.tests.result }}"
          echo "üî® Build: ${{ needs.build.result }}"
          exit 1
